namespace GitBuildInfo
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Text;
    using Microsoft.Build.Framework;
    using Microsoft.Build.Utilities;
    // using LibGit2Sharp;

    /// <summary>
    /// A MSBuild task that generates the msbuild information for an assembly.
    ///
    /// Note: use in the BeforeBuild target.
    /// </summary>
    public class GitBuildInfoTask : Task
    {
        internal bool isGeneric = false;

        /// <summary>
        /// Gets or sets the generated output file path.
        /// </summary>
        [Required]
        public string OutputPath { get; set; }

        /// <summary>
        /// Gets or sets the type to use to get the current assembly to that the attribute is applied to.
        /// </summary>
        [Required]
        public string AssemblyType { get; set; }

        /// <inheritdoc/>
        public override bool Execute()
        {
            var splitted = this.AssemblyType.Contains(".") ? this.AssemblyType.Split('.') : new string[] { };
            var splittedLen = splitted.Length;
            var usingStr = string.Empty;
            foreach (var value in splitted)
            {
                // skip the last value.
                if (value != splitted[splittedLen - 1])
                {
                    if (value != splitted[0])
                    {
                        usingStr += ".";
                    }

                    usingStr += value;
                }
            }

            // Describe(this.OutputPath, out var git_out1);
            // RevParse(this.OutputPath, out var git_out2);
            // NameRev(this.OutputPath, out var git_out3);
            this.RunGit("describe --all --always --dirty", out var git_out1);
            this.RunGit("rev-parse --short HEAD", out var git_out2);
            this.RunGit("name-rev --name-only HEAD", out var git_out3);
            /*
            if (!git_out1.Equals(git_out_1))
            {
                this.Log.LogMessage(MessageImportance.High, "LibGit2 gave wrong value for describe.");
                git_out1 = git_out_1;
            }

            if (!git_out2.Equals(git_out_2))
            {
                this.Log.LogMessage(MessageImportance.High, "LibGit2 gave wrong value for rev-parse.");
                git_out2 = git_out_2;
            }

            if (!git_out_3.Equals(git_out_3))
            {
                this.Log.LogMessage(MessageImportance.High, "LibGit2 gave wrong value for name-rev.");
                git_out3 = git_out_3;
            }
            */

            var outputData = $@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

{(splittedLen > 0 ? $"using {usingStr};{Environment.NewLine}" : string.Empty)}using System.Runtime.InteropServices;

[assembly: GitInformationAttribute(""{git_out1}"", ""{git_out2}"", ""{git_out3}"", typeof({(splittedLen > 0 ? splitted[splittedLen - 1] : this.AssemblyType)}{(this.isGeneric ? "<>" : "")}))]
";
            // patch 112019: only print the getting build info from git message from the initial call to this task.
            // all other calls will not print anything to avoid spamming up the build output.
            try
            {
                if (!File.Exists(this.OutputPath) || (File.Exists(this.OutputPath) && !string.Equals(outputData, File.ReadAllText(this.OutputPath))))
                {
                    this.Log.LogMessage(MessageImportance.High, "Getting build info from git");
                    try
                    {
                        using (var fstream = new StreamWriter(this.OutputPath, false, new UTF8Encoding(false)))
                        {
                            fstream.Write(outputData);
                        }
                    }
                    catch (IOException)
                    {
                    }
                }
            }
            catch (IOException)
            {
            }

            return true;
        }

        private void RunGit(string arguments, out string git_out)
        {
            using (var pro1 = new Process())
            {
                pro1.StartInfo.FileName = "git";
                pro1.StartInfo.Arguments = arguments;
                pro1.StartInfo.RedirectStandardOutput = true;
                pro1.StartInfo.UseShellExecute = false;
                pro1.StartInfo.CreateNoWindow = true;
                pro1.StartInfo.WorkingDirectory = Path.GetFullPath(this.OutputPath).Replace(Path.GetFileName(this.OutputPath), string.Empty);
                try
                {
                    _ = pro1.Start();
                    git_out = pro1.StandardOutput.ReadToEnd();
                    pro1.WaitForExit();

                    // handle all cases of possible endlines.
                    git_out = git_out.Replace("\r\n", string.Empty);
                    git_out = git_out.Replace("\n", string.Empty);
                    git_out = git_out.Replace("\r", string.Empty);
                    // git_out = git_out.Remove(git_out.Length - 1, 1);
                }
                catch (Win32Exception)
                {
                    git_out = "Not a git clone or git is not in Path.";
                }
            }
        }

        /*
        private static void Describe(string repositoryPath, out string git_out)
        {
            using (var repo = new Repository(repositoryPath))
            {
                // repo.Head.Tip;
                // can return heads/{current branch}
                git_out = repo.Describe(repo.Head.Tip,
                    new DescribeOptions { Strategy = DescribeStrategy.All, AlwaysRenderLongFormat = true, });
                // TODO: Check if the current branch is dirty in LibGit2Sharp.
            }
        }

        private static void RevParse(string repositoryPath, out string git_out)
        {
            using (var repo = new Repository(repositoryPath))
            {
                git_out = repo.Describe(repo.Head.Tip,
                    new DescribeOptions { UseCommitIdAsFallback = true });
            }
        }

        private static void NameRev(string repositoryPath, out string git_out)
        {
            using (var repo = new Repository(repositoryPath))
            {
                git_out = repo.Describe(repo.Head.Tip,
                    new DescribeOptions { Strategy = DescribeStrategy.All, AlwaysRenderLongFormat = true, });
                git_out = git_out.Replace("heads/", "");
            }
        }
        */
    }
}
